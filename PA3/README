README file for Programming Assignment 3 (Java edition)
=======================================================

Your directory should now contain the following files:

 build.xml
 README
 cool.cup
 bad.cl
 good.cl
 compare-parser           -> [course dir]/src/PA3J/compare-parser
 myparser                 -> [course dir]/src/PA3J/myparser
 ref-parser               -> [course dir]/src/PA3J/ref-parser
 mycoolc                  -> [course dir]/src/PA3J/mycoolc
 cool-tree.java           -> [course dir]/src/PA3J/cool-tree.java
 cool-tree.aps            -> [course dir]/src/PA3J/cool-tree.aps
 AbstractSymbol.java      -> [course dir]/src/PA3J/AbstractSymbol.java
 AbstractTable.java       -> [course dir]/src/PA3J/AbstractTable.java
 BoolConst.java           -> [course dir]/src/PA3J/BoolConst.java
 CgenClassTable.java      -> [course dir]/src/PA3J/CgenClassTable.java
 CgenNode.java            -> [course dir]/src/PA3J/CgenNode.java
 CgenSupport.java         -> [course dir]/src/PA3J/CgenSupport.java
 ClassTable.java          -> [course dir]/src/PA3J/ClassTable.java
 CoolParser.java          -> [course dir]/src/PA3J/CoolParser.java
 CoolTokenLexer.java      -> [course dir]/src/PA3J/CoolTokenLexer.java
 Flags.java               -> [course dir]/src/PA3J/Flags.java
 IdSymbol.java            -> [course dir]/src/PA3J/IdSymbol.java
 IdTable.java             -> [course dir]/src/PA3J/IdTable.java
 IntSymbol.java           -> [course dir]/src/PA3J/IntSymbol.java
 IntTable.java            -> [course dir]/src/PA3J/IntTable.java
 ListNode.java            -> [course dir]/src/PA3J/ListNode.java
 Parser.java              -> [course dir]/src/PA3J/Parser.java
 StringSymbol.java        -> [course dir]/src/PA3J/StringSymbol.java
 StringTable.java         -> [course dir]/src/PA3J/StringTable.java
 SymbolTable.java         -> [course dir]/src/PA3J/SymbolTable.java
 TokenConstants.java      -> [course dir]/src/PA3J/TokenConstants.java
 TreeConstants.java       -> [course dir]/src/PA3J/TreeConstants.java
 TreeNode.java            -> [course dir]/src/PA3J/TreeNode.java
 Utilities.java           -> [course dir]/src/PA3J/Utilities.java
 *.java                   other generated files

        The build.xml contains targets for compiling and running your
        program. DO NOT MODIFY.
    
        The README contains this info. Part of the assignment is to
        fill in the README with the write-up for your project. You should
        explain design decisions, explain why your code is correct, and why
        your test cases are adequate. It is part of the assignment to
        clearly and concisely explain things in text as well as to comment
        your code. Just edit this file.

        cool.cup is the skeleton for the parser specification that you
        are to write. It already contains productions for the program
        and the classes. Use them as an example to write the remaining
        productions.  You should also read the CUP documentation.
        This skeleton will compile and run as is, but it doesn't
        do much.

        good.cl, bad.cl test a few features of the grammar. You should
        add tests to ensure that good.cl exercises every legal
        construction of the grammar and that bad.cl exercises as many
        different parsing errors as you can squeeze into one file.

        cool-tree.aps contains the definitions for the tree language
        which you use to construct the abstract syntax tree (AST).  From
        this file, cool-tree.java is automatically generated by a
        utility that compiles the specification into Java classes for
        constructing tree nodes.  This file is provided for your
        reference.  DO NOT MODIFY.

        TreeNode.java and ListNode.java contain definitions used by the
        tree package. DO NOT MODIFY.  

        Parser.java contains a driver to test the parser. DO NOT MODIFY.

        Flags.java implements routines for parsing command line
        flags. DO NOT MODIFY.

        tests is a directory containing ten test cases with expected outputs.
        DO NOT MODIFY.

        The rest of the files are created as byproducts of `CUP', or
        are internal parser support files.  DO NOT MODIFY.
        `CoolParser.java' is the generated Java file containing the
        parser.  DO NOT MODIFY this file directly; instead, edit
        cool.cup and this file will be regenerated automatically.

        Files not discussed are covered in the README for PA2J.

Instructions
------------

        To compile your parser program type:

        % ant parser

        This compiles all the classes and produces an shell script named
        "parser" which invokes Parser.main() as the standalone phase of
        the Cool compiler.  It requires lexer, semant, and cgen to do
        anything useful.

        To test your parser on a file 'foo.cl' type

        % myparser foo.cl

        myparser is a shell script that "glues" together lexer and
        parser using pipes.  Don't worry if the line numbers you get by
        running Java version of the parser are slightly off as compared
        to the "official" parser.

        To run your parser on the files good.cl and bad.cl type:

        % ant test

        To run ten examples in tests directory type:

        % ant test-all

        If you think your parser is correct and behaves like
        the one we wrote, you may want to run a COOL compiler using
        your parser:

        % mycoolc foo.cl

        To overwrite the default lexical analyzer with yours, replace 
        lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

        To run the reference parser on a file 'fool.cl':

        % ref-parser foo.cl

        To easily compare your parser and the reference parser:

        % compare-parser foo.cl

        This will create two files: foo.cl.out.my and foo.cl.out.ref

        To turn in your work type:

        % ant submit-clean

        And run the "submit PA3" program. This will automatically collect the
        files good.cl, bad.cl, good.output, bad.output, README, and cool.cup 
        file. Don't forget to edit this README file to include your write-up, 
        and to write your own test cases in good.cl and bad.cl.

        You may turn in the assignment as many times as you like.
        However, only the last version will be retained for
        grading.

        GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3J
-----------------
Design decision:
According to the spec, we should correctly construct the parse tree given correct input. Since CUP is LALR(1) we need to declare precedence and associativity for operators to solve the potential shift/reduce conflicts. For all binary operators except assign and the three comparison operators, we declare left associativity. For all unary operators, we declare right associativity. For assign, we declare right associativity. For the comparison operators, we declare no associativity. Based on CUP manual, "Any terminals not in this declaration have lowest precedence. CUP also assigns each of its productions a precedence. That precedence is equal to the precedence of the last terminal in that production." By not declaring "IN", we make it the lowest precedence and thus make sure the let expression extends as far right as possible. 

The production declaration basically follows the Cool grammar and is pretty straightforward. But the error handling needs to be mentioned. Based on the spec, we only need to catch error and recover from class definition, feature, let variable binding and single expression in block. But after some random testing on error imput, I found the reference parser could also recover from formal parameter error (@Piazza post 282) and we are
not supposed to catch error and recover from the state. Reference parser may also be able to recover from several other error cases also. The difference might cause the reference parser behavior to differ from our parser's behavior in certain testcases. 

The synchronization point for class level error, feature level error, and block expression level error is the semicolon(denoted as "SEMI"). The synchronization point for a let binding is either COMMA or IN. 

We decide to make the feature_list and formal_list non-empty and directly write the empty cases in class and feature declaration. This seems to eliminate some possible ambiguity across empty list. 

We will explain what each testcase does in good.cl and bad.cl.

